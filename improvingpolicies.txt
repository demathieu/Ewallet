
//3: A popup security policy example: 
allow at most 2 popup windows that its URL must be in the whitelist and the new popup window must has location ba

var state = {
	 popuptimes : 0,
	 // the parameters correspond to the ones in handler.set 
	 filter: function(target,name,value,receiver){  
	 	if(popuptimes > 2){
	 		return false;
	 	} else {
			popuptimes++;
			return true;
		}
	}
}
windowSafe = new policyBuilder.policy(state)
							  .deny({method: 'open'})
							  .install(window);



// Mathieu: why filter has all the set arguments?? 
// Mathieu: Deny is working on a Get statement not on a set statement here. 

//4: Policy to disallow iframe creation
locationSafe = new policyBuilder.policy({})
								.deny({method:'createElement', arguments: ['iframe']}).
								.install(document);

// Mathieu :: Making assumtion that (typeof method === "function") == {method:, arguments:}.  Not sure if this is true !!! 


							
//5: Policy preventing leakage of information through loading of new images


								
leakageSafe = new policyBuilder.policy({})
								.deny({propertyUpdate:'src'}).
								.whiteList(collectionAllowedURLs).
								.install(document.image);
								
what whiteList(collectionAllowedURLs) method does is that it overrides the state property that a policy has for the following:

 whiteList: function(collectionAllowedURLs) {
   policy.state = {
	// the parameters correspond to the ones in handler.set 
	 filter: function(target,name,value,receiver){
	 		if (value in collectionAllowedURLs)
				Reflect.set(....);
	}
}
 

//6: writing to the document.location, window.location and the src property of the instances of Frame, IFrame, Image and Form classes should only be permitted if the sensitive data fields have not been previously read or the new location is in an URL whitelist allowed by the policy.
var state = {
	 cookiesRead : false;
	 listenerCookiesRead: {
		// the parameters correspond to the ones in handler.get
		notify: function(target, name, value, receiver) {
			cookiesRead = true;
		}
	 }
	 filter: function(target,name,receiver){
	 	if ( cookiesRead)
		return false;
	}
}


readSensitiveData = new	policyBuilder.policy(state)
								.monitor({propertyRead:'cookies', listener: state.listenerCookiesRead}))
								.install(window);

leakageSafeOnDocumentLocation = new policyBuilder.policy(state)
								.deny({propertyUpdate:'src'}).
								.whiteList(URLcollection).
								.install(document.location);

leakageSafeOnWindowLocation = new policyBuilder.policy(state)
								.deny({propertyUpdate:'src'}).
								.whiteList(URLcollection).
								.install(window.location);								
																

// a nicer version would be to install on multiple targets the same policie, eg:															
leakageSafe = new policyBuilder.policy(state)
								.deny({propertyUpdate:'src'}).
								.whiteList(URLcollection).
								.installOnMultipleTargets([document.location, window.location]);

//7: Policy controlling the redirection of a webpage. 
// Similar to 5 changing property and target


redirectionSafe = new policyBuilder.policy({})
								.deny({propertyUpdate:'location'}).
								.whiteList(allowedURLs).
								.installOnMultipleTargets([document, window]);

//8: Policy preventing impersonation attacks using XMLHttpRequest object.													

locationSafe = new policyBuilder.policy({})
								.deny({method: 'send'},{method: 'open'})
								.whiteList(allowedURLs)
								.install(XMLHttpRequest);
								
calling twice to deny means that now the policy can be denied by either a "set" call to 'send' or 'open'. 
So this means that a policy keeps a list of objects of the type {method: ... arguments:}




//9: Policy preventing potential forgery attacks. This is what we want to allow, the other things should be denied
//window.open("", "", "location=yes,status=yes");
								
locationSafe = new policyBuilder.policy({})
								.whiteList(['','','location=yes,status=yes'])								
								.deny({method: 'open'})
								.install(window)

//11: Policy to disable methods that might cause resource abuse. (Deny access to window.alert and window.prompt)

windowSafe = new policyBuilder.policy({})
							  .deny({method: 'alert'},{method: 'prompt'})
							  .install(window)


//12: The intended policy is to limit the content of a frame to URLs specified by a whitelist

frameSafe = new policyBuilder.policy({})
							 .deny({method: 'assign'})
							 .whiteList(allowedURLs)
							 .install(frame.location)

//13: Bob may read the amount property and invoke the deposit method

accountSafe = new policyBuilder.policy({})
							   .allow({propertyRead:'amount'})
							   .install(account)

accountSafe = new policyBuilder.policy({})
								.allow({method: 'invoke'})
								.install(account)

//14: A policy that restricts a subtree to read- only if the rootâ€™s class name includes example. Meth- ods named shake may also be invoked.

Don't know

//15:Object x has two properties, one of which (secret) is not meant to be readable by the recipient of the wrapper.

xSafe = new policyBuilder.policy({})
						 .deny(method: 'Secret')
						 .install(x)


//16: a policy, which also allows subdomains of the domains in the whitelist

Don't know


//18:
//19:
//20:
//21:
//22:
//23:
//24:

